# Real MySQL 8.0
mysql을 정말 많이 쓰지만 제대로 알고 쓰고 있는건가 싶은 생각이 들어 Real MySQL을 읽고 정리한 자료입니다. 다음책은 noSql로 정해보려고 합니다.

전부 자세하기 정리할 순 없고, 알만한 내용은 패스하고 인상깊은 점 위주로 정리하려고 합니다.

## 01. Intro
mysql은 오히려 오라클에 인수되고 나서 크게 발전한 경우. 5.5 GA 버전부터 엔터프라이즈 에디션은 소스코드가 공개가 안되나 여전히 커뮤니티 에디션은 오픈되어 있음.


### 왜 mysql?
* 가격 
* 비용
* 페이스북 데이터를 오라클 DBMS에 저장하면.. 페이스북은 망할 거라고. 

> 어떤 DBMS를 사용할지 모르겠습니다. 어떤 DMBS가 좋은가요? 라는 질문을 들을 때마다 저자는 항상 “자기가 가장 잘 활용할 수 있는 DBMS가 가장 좋은 DBMS입니다.” 

그래도 고민이 된다면,

* 안정성
* 성능과 기능
* 커뮤니티, 인지도

사실 이건 소프트웨어를 고르는 기준이지 않을까 싶다. popularity에 대한 정보가 필요하다면 DB-Engines.com에서 확인해보자.

그리고 엔터프라이즈를 안쓰더라도 모니터링 등을 Percona MYSQL 등으로 대체 가능

## 02. 설치
운영체제에 맞게 설치하면…실행 명령, shutdown 명령 등등.. 백업은 뒤에 백업 장에서 다루면 되는 거고. 

항상 mysql을 쓰면서, 설정 파일인 my.cnf가 궁금했었다. 주의사항, 설정파일 위주로 

### 디렉토리
기본적으로 /usr/local/mysql로 설치 (Mac 기준)

절대 삭제하면 안되는 디렉터리들

* bin : MySql 서버/클라이언트 프로그램, 유틸리티
* data : 로그파일과 데이터 파일들이 저장되는 디렉터리
* include : C/C++ 헤더 파일들
* lib : 라이브러리 파일들 저장
* share : 다양한 지원 파일들, 에러메시지, 샘플 설정 파일(my.cnf)


### 서버 연결 테스트
```mysql
mysql -uroot -p --host = localhost --socket=/tmp/mysql.sock

mysql -uroot -p --host=127.0.0.1 --port=3306

mysql -uroot -p
```

mysql에서 localhost를 사용하는 것과 127.0.0.1을 사용하는 것은 다름

* localhost : 소켓 파일을 통해 서버에 접속
ㄴ unix domain socket 사용, TCP/IP 아님
ㄴ unix IPC 사용
* 127.0.0.1 : 똑같은 루프백이긴 하지만, TCP/IP 사용
* 세 번쨰는 디폴트로 소켓파일을 읽어서 사용함.

클라이언트를 설치할 수 없는 경우(보안, 번거로움 등)
* telnet, nc 등 활용

### MySQL 서버 업그레이드
1. 서버의 데이터 파일을 그대로 두고 업데이트 하는 경우 : In-Place upgrade
* 제약사항이 있지만, 업그레이드 시간 단축 가능
* 동일 메이저 버전에서 업그레이드 하는 경우, 마이너 버전은 여러 단계 스킵 가능
ㄴ ex. 8.0.16 -> 8.0.21  업그레이드 가능 
* *하지만, 메이저 버전 간에는 직전 버전만 업데이트 가능*
ㄴ 5.5 -> 5.6 가능, 5.5 -> 5.7 불가능 
ㄴ 데이터 파일의 변경이 필요하기 때문. 
ㄴ 5.1에서 8.0으로 업그레이드 해야한다? 5.1 -> 5.5 -> 5.6 -> 5.7 -> 8.0
ㄴ 개귀찮음
ㄴ 간혹가다가 메이저 버전 업그레이드가 특정 마이너 버전에서만 가능한 경우도 있음
ㄴ 인플레이스 업그레이드를 하는 경우 독스를 정독할 것

2. 덤프시킨 다음에 업그레이드된 서버에다가 덤프 데이터 씌우는 방법 : logical update
* 시간이 매우 많이 소요될 수 있음!

### 8.0 업그레이드시 고려 사항
* 사용자 인증 방식 변경 : Caching SHA-2 Authentication이 기본 인증 방식으로 변경. 기존에는 Native Authentication 사용. 
* 8.0과의 호환성 체크
* 외래키 이름길이 : 64자로 제한
* 인덱스 힌트 : 있다면 오히려 성능 저하 생길 수도 있음. 성능 테스트 수행 필요

등등..!

```mysql
mysqlcheck -u root -p --all-databases --check-upgrade
``` 

### 서버 설정
유닉스 계열에서는 my.cnf, 윈도우 계열에서는 my.ini 파일을 사용하는데, mysql 서버는 실행할 때 이 파일을 참고해서 실행 됨. 근데 이 파일의 위치가 *고정되어 있지 않음*, 순차적으로 디렉터리를 탐색하면서 맨 처음 발견된 파일을 사용함. 

```mysql
mysqld --verbose --help

mysql --help
```

[image:43CF155C-7DEE-41B4-BA52-A0C391142FB4-70228-0001FAC1C8578E1D/EE90031C-C367-4F4E-9078-7C5B89190935.png]

위 순서대로 디렉터리 탐색함. 만약 파일이 여러개 있다면, 위 명령어로 어느 순서대로 읽는지 확인해야 함. 

만약 하나의 머신에 2개 이상의 mysql 서버를 돌리는 경우, 디렉터리가 충돌될 수 있기 때문에 별도 디렉터리에 설정하고 시작 스크립트를 변경해야 하는데 그런 경우 거의 없음

#### 설정 파일 구성
```
[mysqld_safe]
mallloc-lib = /opt/lib/libtcmallc_minimal.so

[mysqld]
socket = /usr/local/mysql/tmp/mysql.sock
port=3306

[mysql]
default-character-set = utf8mb4
socket=/usr/local/mysql/tmp/mysql.sock
prot=3304

[mysqldump]
.. =
.. = 
```

위를 보면 설정 파일이 그룹단위로 구분되어 있음. 가령, mysqldump 프로그램은 [mysqldump]만 참고함.  간단하게는 [mysqld]만 있어도 돌아가긴 함. 

설정파일의 각 그룹은 같은 파일에 있지만 서로 무관하게 작용됨.

#### 시스템 변수
MySql 서버가 뜰 때, 위의 설정파일을 싹 읽어 메모리 or 작동방식을 싹 초기화함. 그리고 사용자를 제어하기 위해 이이런 값들을 저장해 두는데, 이걸 시스템 변수라고 함.

```mysql
SHOW GLOBAL VARIABLES
```

이제 이게 글로벌 변수인지, 세션 변수인지 확인할 건데,  변수들을 구분해보자.

[image:6334F6E9-E4CD-4CA6-BF02-FAA9C04869D3-70228-0001FB4749BEDC9D/5E1AD7CC-FBD9-4BBF-AE0A-25347265681E.png]

(https://dev.mysql.com/doc/refman/8.0/en/server-system-variable-reference.html)
(졸라많음)

* Cmd-Line : MySql 서버의 명령행 인자로 설정될 수 있는지 여부. Yes면 명령행 인자로 시스템 변수 값 변경이 가능
* Option file : my.cnf로 이 변수를 제어할 수 있는지 여부. 
* System Var : 시스템 변수인지 아닌지 여부. my.cnf를 작성할 때, 각 변수명에 사용된 하이픈이나 언더스코어 구분 주의해야함 (-,_)  <- 오픈소스로 많은 사람들의 손을 거치며 명명된 일관성 없는 규칙 떄문에… 8.0에서는 _로 통일
ㄴ 명령행 오션으로만 사용 가능한 설정들은 - 를 구분자로 사용
* Var Scope : 시스탬 변수의 적용 범위. 서버 전체인지 (Global) 서버와 클라이언트간의 커넥션 (Session) 혹은 둘 다인지.
* Dynamic : 동적인지 정적인지

#### 글로벌 변수와 세션 변수
일반적으로 세션별로 적용되는 시스템 변수는 글로벌 변수 뿐만 아니라 세션 변수에도 동시 적용됨. Both로 표시

* 글로벌 변수는 하나의 MySql 서버 인스턴스에 전체적으로 영향을 미치는데, 서버 자체에 관련된 것. 가령, InnoDB 버퍼 풀 크기 (innodb_buffer_pool_size) 는 서버에 하나만 존재함. 이런 것.

* 일반적으로 DBMS들은 클라이언트들이 처음 접속하면 기본족으로 부여하는 값들이 있음. 디폴트 값이 있는데, 얘네들은 글로벌 변수임. 별도로 값을 설정하지 않으면 요걸 쓰지만, 만약 별도로 값을 설정해서, 커넥션별로 다르게 쓰고 싶다? 그 때 변경할 수 있는게 세션변수. 즉, 기본값은 글로벌 변수로 가지고, 커넥션단위로 변경해서 쓴다 그러면 그건 세션변수. 가령, autocommit 같은 것들. 커넥션별로 다르게 설정이 가능하고, 서버에서 강제로 변경 불가능함.

#### 정적 변수와 동적 변수
서버가 기동 중인 상태에서 변경이 가능한가?에 따른 구분

MySql에서 시스템 변수는
* 디스크에 저장되어 있는 파일 (my.cnf)를 변경하는 경우
ㄴ 바꾸더라도 서버를 재시작 하지 않으면 반영이 안되겠지?
* 이미 기동중인 서버에서 시스템 변수를 변경하는 경우 
ㄴ set을 사용해 변경 가능, 재시작 안해도 적용됨
ㄴ 근데 set을 해도 디스크에 파일을 변경하지는 못하겠지? -> 8.0부터 SET_PERSIST로 메모리 변경하면서 디스크도 변경 가능 -> 단, my.cnf가 아닌 별도의 파일에 기록

요렇게도 나뉠 수 있음. 

```mysql
SHOW GLOBAL VARIABLES LIKE '%max_connections%'

SET GLOBAL max_connections=5000;

## GLOBAL 빼면 세션변수 조회, 설정
```

> 단, 변수 범위가 Both 인 경우, 글로벌 시스템 변수 값을 변경해도 이미 존재하는 커넥션의 세션 변수값은 변경되지 않음. 동적 타입이어도. 

#### SET PERSIST
동적변수를 변경하면서 설정파일에도 이 내용을 바로 반영해버림. 이게 포인트가, 이전에는 set max_connection = 5000 으로 커넥션 개수를 늘려서 응급 조치를 때린 다음에, 나중에 까먹고 나서 서버 재시작 했다가 다시 장애 나는 경우가 빈번하다고 함.

SET PERSIST 명령을 사용하면, 서버는 변경 값을 즉시 적용하면서 my.cnf가 아닌 별도의 파일 mysqld-auto.cnf에다가 변경내용을 기록함. 

그리고 mysql 서버는 재시동 될 때, my.cnf, mysqld-auto.cnf 를 다 읽어서 적용함. 

SET_PERSIST_ONLY를 사용해 지금 당장 적용은 안하면서 설정파일만 변경도 가능

삭제할 때는 RESET_PERSIST (변수명 or 안쓰면 mysql-auto.cnf 전체 삭제)

## 03. 사용자 및 권한 
### 사용자 식별
mysql에서는 계정 뿐만 아니라, *접속 지점(클라이언트의 호스트명, 도메인, IP주소)* 까지 계정의 일부로 사용됨. 따라서 아이디와 호스트를 함꼐 명시해야됨.

가령

> ‘svc_id’@’127.0.0.1’

얘는 다른 컴퓨터에서는 svc_id로 접속이 안됨.

만약 모든 곳에서 접속이 가능한 애를 생성하고 싶으면, %를 사용하면 됨

> ’svc_id’@‘192.168.0.10’ // 비밀번호 123
> ’svc_id’@‘%’  // 비밀번호 abc

만약, 192.168.0.10 여기서 ‘svc_id’로 접속하면?
-> *범위가 좁은 것*으로 인증을 함. 
-> 따라서, abc로 로그인 하면 로그인이 안될 거임.

### 시스템 계정
‘root’@‘localhost’ 말고, 

[image:755275DA-98C6-43A3-B88E-90F3B03EA6E3-70228-0001FD008B1143B3/438A29D8-CA49-4C5F-B62E-B06D184B1865.png]

* mysql.sys@localhost : 기본으로 내장된 sys 스키마의 객체들의 디파이너로 사용
* mysql.session@localhost : mysql 플러그인이 서버로 접근 할 떄
* mysql.infoschema@localhost : information_schema에 정의된 뷰의 디파이너. 

얘네는 락이 걸려있어서 의도적으로 풀고 지우는게 아니면 지우긴 어렵지만, 절대 삭제되면 안됨

### 계정 생성
5.7까지는 GRANT 명령으로 생성과 권한 부여가 동시에 가능해졌지만, 8.0에서는 CREATE / GRANT로 나눠서 해야됨. 

```mysql
CREATE USER 'user'@'%'
	IDENTIFIED WITH 'mysql_native_password' BY 'password'
	REQUIRE NONE
	PASSSWORD EXPIRE INTERNAL 30 DAY
	ACCOUNT UNLOCK
	PASSWORD HISTORY DEFAULT
	PASSWORD REUSE INTERVAL DEFAULT:
	PASSWORD REQUIRE CURRENT DEFUALT:
```

#### IDENTIFIED WITH
인증 방식과 비밀번호를 설정하는 옵션인데, 만약 기본 인증식을 사용하고 싶으면 IDENTIFIED BY ‘password’를 하면 됨. 근데 이제 인증 방식을 다양한걸 제공 하는데 대충 4가지가 있음

* Native Pluggable Authentication : 5.7까지 사용되던 방법. 단순히 비밀번호에 대한 SHA-1 해시값을 저장해두고, 클라이언트가 보낸 값과 해시값이 일치하는지 비교

* Caching SHA-2 Pluggable Authentication : 5.6에 도입되서 8.0부터 본격적으로 사용됨. SHA-2(256비트) 알고리즘 사용. native랑 다른 점은, 알고리즘이 달라 보안을 강화했다는거
ㄴ native 플러그인은 동일 입력에 동일한 해시값을 출력하지만, 얘는 솔트값을 써서 수천번 해시 해서 결과를 만들어서, 동일 키값에 대래서도 값이 달라짐. 당연히 성능 떨어지겠지? 그래서 결과값을 메모리에 캐시해서 사용함. 그래서 Caching. 근데 이 인증 방식 쓰려면 SSL/TLS or RSA 키페어를 반드시 사용해야함. 

* PAM Pluggable Authentication : 뭐 LDAP 쓴다나봄. 엔터프라이즈만 가능
* LDAP Pluggable Authentication : 얘도 뭐 엔터프아지므ㅏㄴ 가능

8.0부터는 Caching SHA-2 Pluggable Authentication 얘가 기본인증인데, 그럴라믄 SSL/TLS or RSA 키페어가 필요해서 연결방식이 달라짐. 번거로우니까 Native Authentication을 쓴다 하면. 

my.cnf를 변경하거나

SET GLOBAL default_authentication_plugin = “mysql_native_password” 

> Caching SHA-2 Pluggable Authentication 얘는 SCRAM (Salted Challenge response Authentication Mechanism) 방식인데, 얘는 평문 비밀번호를 5000번 이상 해시 함수를 실행해여 MySQL 서버로 로그인 요청을 보낼 수 있음. 브루트포스가 어려워 짐. 근데 이러면.. 일반 선량한 사용자도 접근이 느려져버림. 물론 딱 5000번만 실행되겠지만.. 근데 커넥션이 많은 경우에는 CPU 사용량이 빡셈. 그래서, caching_sha2_password_digest_rounds 시스템 변수를 설정할 수 있음. 최소 설정 값은 5000

#### REQUIRE
SSL/TLS 쓸지. 

#### PASSWORD EXPIRE
비밀번호 유효기간. default_password_lifetime 시스템 변수 저장. 

#### PASSWORD_HISTORY
한번 사용했던 비밀번호를 재사용 하지 못하게 설정하는 옵션. 

등등… 나머지는 문서 참조하면 충분..

### 비밀번호 관리
금칙어, 이력관리, 등등의 유효성 체크를 할 수 있는데 요거는 validate_password 컴포넌트를 사용하면 됨. 설치

```
INSTALL COMPONENT 'file://component_validate_password';
```

확인

[image:52E2F2CA-5DE4-4AC8-B044-7727D50A7F7E-70228-0001FDEF27D7BED0/65292DCC-9DA7-4D55-8914-AC85AFBE7535.png]

[image:01F5D623-57FA-40CB-94EC-F5833AA2B73F-70228-0001FDF7F685767D/51F5B5ED-4D81-4C46-9F9B-79F939B5A575.png]

정책은 크게 세가지

* LOW : 비밀번호의 길이만
* MEDIUM : 비밀번호의 길이 검증, 숫자, 대문자, 특수문자 배합 검증
* STRONG : MEDIUM + 금칙어까지 검증 

위의 시스템 변수에 설정된 것들로 검증함.  금칙어 파일을 만들고 싶으면, 금칙어들을 한줄에 기록해서 validate_password.dictionary_file 시스템 변수에 사전 파일 등록하면 됨. 
ㄴ 이거 다 쓰기 에바라서, 깃헙등에서 파일 받아서 쓰는게 좋음

#### 이중 비밀번호
RETAIN CURRENT PASSWORD 키워드를 통해 적용.
이게 약간, 비밀번호를 바꾸고 싶은데 지금 바꿀라면 지금 비번을 공유하는 어플리케이션들을 다 종료시켜야되는데  그러기가 쉽지 않을 때 쓰는 거. 일단 이걸로 이중 비밀번호를 걸고, (최근에 설정된게 Primary, 기존꺼가 Secondary가 됨)

나중에 서비스들 내릴 수 있을 때 Primary로 다시 접속시키고 Secondary는 지우게 하면 됨.

### 권한, 역할
어우 너무많아

## 04 아키텍쳐
MySQL 서버의 구조
* 머리 : MySQL 엔진
* 손발 : 스토리지 엔진 (핸들러, 핸들러 API만 만족하면 누구나 구현해서 갈아 끼워버릴 수 있음, InnoDB, MyISAM 등)

[image:3785E882-A9EC-4B8A-A693-2276F6A4C017-70228-0001FE9D12BF88B8/154495756-a73e38e2-15d5-42d1-9a33-929f32bb6d91.png]


### MySQL 엔진
* 커넥션 핸들러 : 클라이언트로부터의 접속 및 쿼리 요청을 처리
* SQL 파서, 전처리기
* 옵티마이저 
* 표준 SQL(ANSI SQL)지원

#### 스토리지 엔진 
MySQL 엔진이 요청된 SQL 문을 분석, 최적화 한다면 (머리) 이제 디스크 스토리지에 저장하거나 읽어오는건 스토리지 엔진이 전담.  하나의 서버에서, 엔진은 하나지만 스토리지 엔진은 여러개를 사용할 수 있음

```mysql
CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
```

요렇게 나는 InnoDB를 쓸거야! 라고 테이블에 지정 가능. 

### 핸들러 API
이제 쿼리 실행기에서 데이터를 쓰고 읽을 때 스토리지 엔진에 쓰기/읽기 요청을 보내는데, 그걸 핸들러 요청이라고 하고, 여기에 사용되는 API를 핸들러 API라고 함.

### MySQL 스레딩 구조
[image:F42E919F-9819-414A-A54A-7500410CE2D5-70228-0001FEEE5446CC32/157605091-c3bf7014-37ed-49b6-82ac-a5fbb32452b9.png]

MySQL은 프로세스 기반이 아니라 스레드 기반. 크게 포그라운드 / 백그라운드로 구분

아래와 같이 performance_schema에서 확인 가능

[image:DB8FA5EF-9A2B-400F-92EE-ACAE236A6968-70228-0001FF05B5772410/1A53E939-D322-4863-B778-F1840F283E13.png]

총 44개 중에서, 41개가 백그라운드고 3개만 포그라운드임.  특히, 그 중에서 맨 아래 thread/sql/one_connection 얘만 실제 사용자의 요청을 처리하는 포그라운드 스레드. 

스레드 개수는 가변적일 수 있고, 동일 이름이 2개씩 있는건 병렬로 처리하는 경우

> 단, 이건 전통적인 구조이고, 커뮤니티 버전에서 사용중. 엔터프라이즈 버전에서는 스레드 풀 모델을 사용함.  기존에는 포그라운드 스레드가 커넥션별로 하나씩 생성되지만, 쓰레드 풀에서는 하나의 쓰레드가 여러 커넥션 요청을 전담함
 

#### 포그라운드 스레드
= 사용자 스레드 
* 최소한 MySQL 서버에 접속한 클라이언트 수만큼 존재. 
* 주로 쿼리 문장 처리
* 작업을 마치면 스래드 캐시로 돌아감
* 만약 스레드 캐시에 일정 수 이상이 있으면 종료시켜버림
* thread_cache_size 변수로 조절 가능

하는일?
* 데이터 버퍼나 캐시로부터 가져와서, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리
* MyISAM에서는 포그라운드가 디스크 쓰기까지 다 하지만, InnoDB에서는 *버퍼나 캐시까지만 스레드가 처리하고, 나머지 디스크에다가 기록하는건 백그라운드가 처리*

#### 백그라운드 스레드
MyISAM에서는 별로 해당사항이 없는데 InnoDB에서는 다음 작업들이 처리됨

* 인서트 버퍼를 병합하는 스레드
* *로그를 디스크로 기록하는 스레드*
* *InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드*
* 데이터를 버퍼로 읽어오는 스레드
* 잠금이나 데드락을 모니터링하는 스레드

여기서 제일 중요한건 로그 스레드, write thread sleep, 5.5버전부터 쓰기 쓰레드와 읽기 쓰레드의 개수 2개 이상 지정할 수 있게 됨.

* innodb_write_io_threads
* innodb_read_io_threads
ㄴ innodb에서도 read 작업은 주로 클라이언트 스레드가 처리하는데 많이는 필요 없지만, write 스레드는 아주 많은 작업을 백그라운드에서 처리해서 2-4개 정도가 적절. 디스크를 최적으로 사용할 수 있을 만큼.

> 쓰기 작업은 지연(버퍼링)되어 처리가 가능하지만, 읽기는 절대 지연이 안됨. 따라서 상용 DBMS는 대부분 쓰기 작업을 버퍼링 해서 일괄 처리함. InnoDB는 그런데 MyISAM은 안그러고 클라이언트 쓰레드가 다함. 따라서, InnoDB에서는 쿼리로 데이터가 변경되는 경우 데이터가 디스크의 데이터 파일로 완전히 저장될 때 까지 기다리지 않아도 됨.

#### 메모리 할당 및 사용 구조
[image:80E0A0AA-5A3B-4107-8EA1-ABECC70967AF-70228-0001FFAE23E7F3EF/image.png]

뭐 운영체제에서 다 줄수도 있고 필요할 떄마다 줄 수도 있고 하긴 한데 무튼. 이건 복잡하니까 걍 시스템 변수만큼 할당받는다고 생각하자..

글로벌 메모리 영역
* 스레드 수와 무관하게 하나만

로컬 메모리 영역
* 클라이언트 스레드가 사용하는 메모리 공간이라고 해서 클라이언트 메모리라고도 함. 
* 세션 메모리라고도 하고
* 스레드별로 독립적으로 할당되며 절대 공유되지는 않음 

### 플러그인 스토리지 모델
[image:65BD4752-87F8-4695-9D59-3BFD960BBA75-70228-000200081462DBA5/image.png]

Mysql 구조중 독특한 부분. 플러그인해서 사용할 수 있는건 스토리지 엔진만 있는게 아니라, 검색어 파서, 아까 봤던 Native Authentiacation, Caching SHA-2 Authentication 등도 모두 플러그인으로 구현됨. 

MySql에는 이미 스토리지 엔진이 많이 있는데, 요구사항이 뭐 아주 까다로운 경우에는 지가 개발하면 됨. 

[image:9389B277-7795-4082-98E3-4976095634AD-70228-00020021DFA715CE/image.png]

쿼리 실행되는 과정인데, 거의 대부분이 MySQL 엔진에서 처리가 되고 마지막 read/write만 스토리지 엔진에서 처리가 되기 때문에.

#### 핸들러?
MySQL 소스코드에서 넘어온 표현. 스토리지 엔진을 조정하기 위해 사용한다는.. 그런 개념적인 내용. 

대충 MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸들러를 통해야 한다는 것. 


[image:11BA8DE3-888C-43C2-AB86-BB3C0BFAEB16-70228-0002005A6FA308DA/93374777-81E3-4DD9-A872-B5F91C09339C.png]

#### 컴포넌트
8.0부터 기존의 플러그인 아키텍쳐를 대체하기 위한 컴포넌트 아키텍쳐

 * 플러그인은 오직 MySQL 서버와 인터페이스 할 수 있고 플러그인 끼리는 통신 불가능
 * 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음. 캡슐화 안됨
 * 상호 의존관계를 설정할 수 없어서 초기화가 어려움

###  쿼리 실행 구조
[image:3DA4EB35-43D4-4002-BCD5-330747950D84-70228-000200738497BD64/154495992-9093bdc4-a539-4dc0-9ee1-e6d35a726d60.png]

#### 쿼리 파서
사용자 요청으로 들어온 쿼리 문장을 토큰 (MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)로 분리해 트리 형태로 만들어내는 작업. 

문법 오류가 여기서 잡힘

#### 전처리기
트리를 기반으로, 구조적 문제점이 있는지 확인. 각 토큰을 테이블 이름, 컬럼 이름, 내장함수 요런 것들을 매핑해서 존재 여부, 접근 권한 등을 체크

뭐 테이블이 없어, 컬럼이 없어, 권한이 없어, 이런 에러들이 여기서 걸러짐

#### 옵티마이저
사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할. 두뇌 역할. 가장 중요. 앞으로 내용들도 다 옵티마이저가 뭘 하냐, 어떻게 해야 더 나은 선택을 하도록 유도하냐.

#### 실행 엔진
옵티마이저가 경영진, 실행 엔진은 중간 관리자, 핸들러는 실무자로 보면 될듯. 

만약 group by 가 들어왔는데 옵티마이저가 “임시 테이블을 사용하자”라고 결정을 한다면

1. 실행엔진이 핸들러에게 임시 테이블 만들라고 요청
2. 실행 엔진이 where 절에 일치하는 레코드를 읽아오라고 핸들러에게 요청
3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 요청
4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어오라고 다시 요청
5. 최종적으로 결과를 사용자나 다른 모듈에 넘김

#### 핸들러(스토리지 엔진)
디스크 read write

